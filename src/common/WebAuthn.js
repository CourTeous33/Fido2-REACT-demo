import CBOR from 'cbor-sync';
///////// START UTIL FUNCTIONS /////////
// easy way to go from string to ByteArray
const enc = new TextEncoder();

// another function to go from string to ByteArray, but we first encode the
// string as base64 - note the use of the atob() function
// eslint-disable-next-line
function strToBin(str) {
    return Uint8Array.from(atob(str), c => c.charCodeAt(0));
}

// function to encode raw binary to string, which is subsequently
// encoded to base64 - note the use of the btoa() function
function binToStr(bin) {
    return btoa(new Uint8Array(bin).reduce(
        (s, byte) => s + String.fromCharCode(byte), ''
    ));
}
///////// END UTIL FUNCTIONS /////////

///////// START WEBAUTHN FUNCTIONS /////////
const createCreds = async function(userName) {
    console.log(userName)
    ////// START server generated info //////
    // the below "publicKey" variable is typically generated by your server - here for DEMO purposes only
    const serverChall = "ThisIsTheOnlyKeyToVerifyYouAreAtTheRightPlace";
    const publicKey = {
        challenge: Uint8Array.from(
            serverChall, c => c.charCodeAt(0)),
        rp: {
            name: "Charles",
            id: "y33.ch",
        },
        user: {
            id: enc.encode(userName),
            name: userName,
            displayName: userName
        },
        pubKeyCredParams: [
            {
                type: "public-key", alg: -7 // "ES256" IANA COSE Algorithms registry
            }
        ],
        timeout: 60000,
    }

    console.log(publicKey)
    ////// END server generated info //////
    
    // browser receives the publicKey object and passes it to WebAuthn "create" API
    const res = await navigator.credentials.create({
        publicKey: publicKey
    })
    .catch((err) => {
        console.log(err);
        alert("failed");
        return;
    });

    console.log(res);
    console.log(res.response.attestationObject);
    // note: a CBOR decoder library is needed here.
    // const decodedAttestationObj = CBOR.decode(res.response.attestationObject);
    const encodedAttObj = new Uint8Array(res.response.attestationObject);
    console.log(encodedAttObj);
    const decodedAttestationObj = CBOR.decode(encodedAttObj, 'base64');

    const {authData} = decodedAttestationObj;
    console.log(authData);
    const dataView = new DataView(
        new ArrayBuffer(2));
    const idLenBytes = authData.slice(53, 55);
    idLenBytes.forEach(
        (value, index) => dataView.setUint8(
            index, value));
    const credentialIdLength = dataView.getUint16();
    console.log(credentialIdLength)
    // get the credential ID
    const credentialId = authData.slice(
        55, 55 + credentialIdLength);
    
    console.log(credentialId);
    alert("registed successful")
    // const encodedCId = new TextDecoder("utf-8").decode(credentialId);
    const arr = Array.from // if available
        ? Array.from(credentialId) // use Array#from
        : credentialId.map(v => v); // otherwise map()
    // now stringify
    const encodedCId = JSON.stringify(arr);
    console.log(encodedCId);

    // Below two lines store the most important info - the ID representing the created credentials
    // Typically they are sent via POST to your server, not stored locally - here for DEMO purposes only
    // const userIds = {
    //     rawId: res.rawId,
    //     id: res.id,
    //     cId: credentialId,
    // }
    localStorage.setItem(userName, encodedCId);
}

const validateCreds = async function(userName){
    
    ////// START server generated info //////
    // Usually the below publicKey object is constructed on your server
    // here for DEMO purposes only
    const encodedCId = localStorage.getItem(userName);
    const cId = new Uint8Array(JSON.parse(encodedCId));
    if (cId == null) {
        alert("Invalid user name");
        return;
    }
    console.log(encodedCId);
    // const cId = new TextEncoder("utf-8").encode(encodedCId);
    console.log(cId);
    const AUTH_CHALLENGE = 'ThisIsTheOnlyKeyToVerifyYouAreAtTheRightPlace'
    const publicKey = {
        // random, cryptographically secure, at least 16 bytes
        challenge: Uint8Array.from(AUTH_CHALLENGE, c => c.charCodeAt(0)),
        allowCredentials: [{
          id: cId.buffer,
          type: 'public-key',
        }],
        userVerification: "preferred",
    };
    ////// END server generated info //////
    console.log(publicKey.allowCredentials);

    // browser receives the publicKey object and passes it to WebAuthn "get" API
    const res = await navigator.credentials.get({
        publicKey: publicKey
    });

    
    console.log(res);

    // here we build an object containing the results, to be sent to the server
    // usually "extractedData" is POSTed to your server
    const extractedData = {
        id: res.id,
        rawId: binToStr(res.rawId),
        clientDataJSON: binToStr(res.response.clientDataJSON)
    }

    // Usually done on the server, this is where you make your auth checks
    // here for DEMO purposes only
    const dataFromClient = JSON.parse(atob(extractedData.clientDataJSON));
    const retrievedChallenge = atob(dataFromClient.challenge);
    // eslint-disable-next-line
    const retrievedOrigin = dataFromClient.origin;

    // At MINIMUM, your auth checks should be:
    // 1. Check that the retrieved challenge matches the auth challenge you sent to the client, as we do trivially below
    // 2. Check that "retrievedOrigin" matches your domain - otherwise this might be a phish - not shown here
    console.log(retrievedChallenge);
    if (retrievedChallenge === AUTH_CHALLENGE){
        alert("Authorized");
    } else {
        alert("Unauthorized");
    }
}

///////// END WEBAUTHN FUNCTIONS /////////

export { createCreds, validateCreds }